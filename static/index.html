<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nn_monitor</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0a0a0a;
            --surface: #111;
            --border: #222;
            --text: #888;
            --text-bright: #eee;
            --health-good: #4a9;
            --health-warn: #c84;
            --health-bad: #f45;
            --pulse: rgba(74, 153, 137, 0.1);
        }

        body {
            font-family: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-size: 11px;
            letter-spacing: -0.02em;
            line-height: 1.4;
        }

        /* Header - ultra minimal */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
        }

        .brand {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--text-bright);
        }

        .status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--health-good);
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected { background: var(--health-bad); animation: none; }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.9); }
        }

        /* History controls section */
        .history-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
        }

        /* Mode badge */
        .mode-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 3px;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 600;
            background: var(--bg);
            border: 1px solid var(--border);
        }

        .mode-badge.live {
            background: rgba(74, 153, 137, 0.15);
            border-color: var(--health-good);
            color: var(--health-good);
        }

        .mode-badge.live .badge-dot {
            background: var(--health-good);
            animation: pulse 2s infinite;
        }

        .mode-badge.paused {
            background: rgba(200, 132, 68, 0.15);
            border-color: var(--health-warn);
            color: var(--health-warn);
        }

        .mode-badge.paused .badge-dot {
            background: var(--health-warn);
            animation: none;
        }

        .badge-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* Live/Pause button */
        .btn-live {
            padding: 6px 14px;
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-bright);
            font-family: inherit;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.15s;
        }

        .btn-live:hover {
            border-color: #333;
        }

        .btn-live.live-active {
            background: rgba(74, 153, 137, 0.2);
            border-color: var(--health-good);
            color: var(--health-good);
            animation: subtle-pulse 2s infinite;
        }

        .btn-live.paused-active {
            background: rgba(200, 132, 68, 0.2);
            border-color: var(--health-warn);
            color: var(--health-warn);
        }

        @keyframes subtle-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(74, 153, 137, 0.4); }
            50% { box-shadow: 0 0 0 3px rgba(74, 153, 137, 0); }
        }

        /* Navigation controls */
        .nav-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .nav-btn:hover:not(:disabled) {
            border-color: #333;
            color: var(--text-bright);
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Slider */
        .step-slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .step-slider {
            flex: 1;
            min-width: 120px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--border);
            outline: none;
            border-radius: 2px;
        }

        .step-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--text-bright);
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.15s;
        }

        .step-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: var(--health-good);
        }

        .step-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--text-bright);
            cursor: pointer;
            border: none;
            border-radius: 50%;
            transition: all 0.15s;
        }

        .step-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            background: var(--health-good);
        }

        .step-slider:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .step-display {
            min-width: 60px;
            text-align: right;
            font-size: 10px;
            font-variant-numeric: tabular-nums;
            color: var(--text-bright);
        }

        /* Main layout */
        main {
            flex: 1;
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 1px;
            background: var(--border);
        }

        /* Sidebar - run selector and summary */
        aside {
            background: var(--bg);
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .control label {
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text);
        }

        select {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-bright);
            padding: 6px 8px;
            font-family: inherit;
            font-size: 10px;
            border-radius: 0;
            cursor: pointer;
            outline: none;
        }

        select:hover { border-color: #333; }
        select:focus { border-color: var(--health-good); }

        .summary {
            margin-top: auto;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }

        .summary-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 10px;
        }

        .summary-item .value {
            color: var(--text-bright);
            font-variant-numeric: tabular-nums;
        }

        /* Layer grid */
        .layers {
            background: var(--bg);
            padding: 12px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 8px;
            align-content: start;
        }

        .layer {
            border: 1px solid var(--border);
            padding: 10px;
            position: relative;
            transition: border-color 0.15s;
        }

        .layer:hover {
            border-color: #333;
        }

        .layer.warning { border-color: var(--health-warn); }
        .layer.critical { border-color: var(--health-bad); }

        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .layer-name {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-bright);
            letter-spacing: 0.02em;
        }

        .layer-type {
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text);
        }

        /* Pulse visualization - the living heartbeat */
        .pulse-viz {
            height: 24px;
            background: var(--surface);
            position: relative;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .pulse-line {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* Metrics row */
        .metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .metric {
            text-align: center;
        }

        .metric-value {
            font-size: 13px;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            transition: color 0.15s;
        }

        .metric-label {
            font-size: 7px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text);
            margin-top: 2px;
        }

        /* Health colors */
        .good { color: var(--health-good); }
        .warn { color: var(--health-warn); }
        .bad { color: var(--health-bad); }

        /* Empty state */
        .empty {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text);
            font-size: 11px;
        }

        .empty::before {
            content: '◷';
            font-size: 32px;
            margin-bottom: 12px;
            opacity: 0.3;
            animation: pulse 2s infinite;
        }

        /* Alerts strip */
        .alerts {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--surface);
            border-top: 1px solid var(--border);
            padding: 8px 12px;
            display: flex;
            gap: 12px;
            align-items: center;
            font-size: 10px;
            transform: translateY(100%);
            transition: transform 0.2s;
            z-index: 10;
        }

        .alerts.visible {
            transform: translateY(0);
        }

        .alert {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .alert-icon { color: var(--health-warn); }
        .alert.critical .alert-icon { color: var(--health-bad); }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border); }
        ::-webkit-scrollbar-thumb:hover { background: #333; }
    </style>
</head>
<body>
    <header>
        <div class="brand">nn_monitor</div>
        <div class="status">
            <span class="status-dot" id="statusDot"></span>
            <span id="statusText">connecting</span>
        </div>
    </header>

    <div class="history-controls">
        <div class="mode-badge live" id="modeBadge">
            <span class="badge-dot"></span>
            <span id="modeText">Live</span>
        </div>

        <button class="btn-live live-active" id="btnLivePause">⏸ Pause</button>

        <div class="nav-controls" id="navControls" style="opacity: 0.3; pointer-events: none;">
            <button class="nav-btn" id="btnFirst" title="First step">⏮</button>
            <button class="nav-btn" id="btnPrev" title="Previous step">◀</button>
            <button class="nav-btn" id="btnNext" title="Next step">▶</button>
            <button class="nav-btn" id="btnLast" title="Latest step">⏭</button>
        </div>

        <div class="step-slider-container">
            <input type="range" class="step-slider" id="stepSlider" min="0" max="100" value="0" disabled>
            <span class="step-display" id="stepDisplay">—</span>
        </div>
    </div>

    <main>
        <aside>
            <div class="control">
                <label>Run</label>
                <select id="runSelect">
                    <option value="">select run...</option>
                </select>
            </div>

            <div class="summary">
                <div class="summary-item">
                    <span>step</span>
                    <span class="value" id="stepVal">—</span>
                </div>
                <div class="summary-item">
                    <span>layers</span>
                    <span class="value" id="layerVal">—</span>
                </div>
                <div class="summary-item">
                    <span>updated</span>
                    <span class="value" id="timeVal">—</span>
                </div>
            </div>
        </aside>

        <div class="layers" id="layers">
            <div class="empty">awaiting data...</div>
        </div>
    </main>

    <div class="alerts" id="alerts"></div>

    <script>
        const state = {
            ws: null,
            runs: {},
            currentRun: null,
            runData: null,
            history: {}, // { layerId: [{step, actStd, gradNorm}, ...] }
            // History navigation state
            isLiveMode: true,           // true = showing live updates, false = paused on specific step
            selectedStep: null,         // step number being viewed (null = latest when liveMode)
            stepsList: [],              // sorted list of all available step numbers for current run
            lastSeenStep: null,         // track the last step we saw for smart resume
            lastViewedStep: null,       // track the last step the user was viewing before live mode
            isTrainingActive: true      // track if training is still receiving updates
        };

        const CONFIG = {
            historyLen: 50,
            trainingTimeoutMs: 10000,
            thresholds: {
                gradNorm: { low: 0.001, high: 10 },
                gradMax: { high: 10 },
                actRatio: { low: 0.5, high: 2 }
            }
        };

        // WebSocket
        function connect() {
            const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
            state.ws = new WebSocket(`${proto}//${location.host}/ws`);

            state.ws.onopen = () => setStatus(true, 'live');
            state.ws.onclose = () => {
                setStatus(false, 'reconnecting');
                // Try to reconnect after 2 seconds
                setTimeout(() => {
                    if (state.ws?.readyState === WebSocket.CLOSED) {
                        connect();
                    }
                }, 2000);
            };
            state.ws.onerror = () => setStatus(false, 'error');
            state.ws.onmessage = (e) => {
                try {
                    handleMessage(JSON.parse(e.data));
                } catch (err) {
                    console.error('Failed to handle WebSocket message:', err, e.data);
                }
            };
        }

        function setStatus(connected, text) {
            document.getElementById('statusDot').classList.toggle('disconnected', !connected);
            document.getElementById('statusText').textContent = text;
        }

        function handleMessage(msg) {
            switch(msg.type) {
                case 'initial_runs':
                    state.runs = msg.data;
                    updateSelect();
                    // Update status to live since we successfully received data
                    setStatus(true, 'live');
                    break;

                case 'new_metrics':
                    if (!state.runs[msg.run_id]) {
                        state.runs[msg.run_id] = {
                            created_at: new Date().toISOString(),
                            last_update: new Date().toISOString(),
                            step_count: 0
                        };
                        updateSelect();
                    }

                    if (!state.currentRun && Object.keys(state.runs).length) {
                        selectRun(msg.run_id);
                    }

                    if (msg.run_id === state.currentRun) {
                        resetTrainingTimeout();
                        addStep(msg.data);

                        // Update step_count based on actual steps array
                        if (state.runData && state.runData.steps) {
                            state.runs[msg.run_id].step_count = state.runData.steps.length;
                            state.runs[msg.run_id].last_update = new Date().toISOString();
                            updateSelect();
                        }

                        // If in paused mode, update UI elements but don't disrupt the user's view
                        if (!state.isLiveMode) {
                            updateStepsList();
                            updateHistoryUI();
                        }
                    }
                    break;

                case 'run_history':
                    state.runData = msg.data;
                    msg.data.steps.forEach(addStep);
                    if (msg.data.steps.length > 0) {
                        state.lastSeenStep = msg.data.steps[msg.data.steps.length - 1].step;
                    }
                    // Update step_count in runs info
                    if (state.runs[msg.run_id] && state.runData) {
                        state.runs[msg.run_id].step_count = state.runData.steps.length;
                        updateSelect();
                    }
                    break;
            }
        }

        function updateSelect() {
            const sel = document.getElementById('runSelect');
            const cur = sel.value;
            sel.innerHTML = '<option value="">select run...</option>';
            Object.entries(state.runs).forEach(([id, info]) => {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = `${id} (${info.step_count || 0} steps)`;
                sel.appendChild(opt);
            });
            if (cur && state.runs[cur]) sel.value = cur;
        }

        function selectRun(id) {
            state.currentRun = id;
            document.getElementById('runSelect').value = id;
            state.history = {};

            // Reset history navigation state
            state.isLiveMode = true;
            state.selectedStep = null;
            state.stepsList = [];
            state.isTrainingActive = true;
            state.lastSeenStep = null;
            state.lastViewedStep = null;
            resetTrainingTimeout();

            updateHistoryUI();

            if (state.ws?.readyState === WebSocket.OPEN) {
                state.ws.send(JSON.stringify({ action: 'subscribe_run', run_id: id }));
            }
        }

        document.getElementById('runSelect').addEventListener('change', (e) => {
            if (e.target.value) selectRun(e.target.value);
        });

        // Toggle between live and paused mode
        function toggleLiveMode() {
            const wasPaused = !state.isLiveMode;

            if (wasPaused) {
                // Returning to live mode - check if training is still active
                if (!state.isTrainingActive && state.lastViewedStep !== null) {
                    // Training ended, stay on last viewed step (remain in paused mode)
                    state.selectedStep = state.lastViewedStep;
                    state.isLiveMode = false;
                } else {
                    // Training is active, go to live mode
                    state.isLiveMode = true;
                    state.selectedStep = null;
                    state.lastViewedStep = null;
                }
            } else {
                // Pausing - capture current step
                const steps = state.runData?.steps || [];
                if (steps.length > 0) {
                    state.selectedStep = steps[steps.length - 1].step;
                }
                state.isLiveMode = false;
                state.lastViewedStep = null;
            }

            updateHistoryUI();
            render();
        }

        // Update UI based on current mode
        function updateHistoryUI() {
            const modeBadge = document.getElementById('modeBadge');
            const modeText = document.getElementById('modeText');
            const btnLivePause = document.getElementById('btnLivePause');
            const navControls = document.getElementById('navControls');
            const stepSlider = document.getElementById('stepSlider');
            const stepDisplay = document.getElementById('stepDisplay');

            const steps = state.runData?.steps || [];
            const currentStep = state.isLiveMode ? (steps[steps.length - 1]?.step ?? null) : state.selectedStep;
            const totalSteps = steps.length;
            const stepIndex = state.stepsList.indexOf(currentStep);

            if (state.isLiveMode) {
                // Live mode
                modeBadge.className = 'mode-badge live';
                const trainingStatus = state.isTrainingActive ? 'Live' : 'Live (ended)';
                modeText.textContent = trainingStatus;
                btnLivePause.className = 'btn-live live-active';
                btnLivePause.textContent = '⏸ Pause';

                navControls.style.opacity = '0.3';
                navControls.style.pointerEvents = 'none';
                stepSlider.disabled = true;

                stepDisplay.textContent = steps.length > 0 ? `step ${steps[steps.length - 1].step}` : '—';
            } else {
                // Paused mode
                const stepLabel = totalSteps > 0 ? `${stepIndex + 1} / ${totalSteps}` : '—';
                modeBadge.className = 'mode-badge paused';
                modeText.textContent = `Paused @ ${stepLabel}`;
                btnLivePause.className = 'btn-live paused-active';
                btnLivePause.textContent = '▶ Live';

                navControls.style.opacity = '1';
                navControls.style.pointerEvents = 'auto';
                stepSlider.disabled = false;

                stepDisplay.textContent = currentStep !== null ? `step ${currentStep}` : '—';

                // Update slider
                if (state.stepsList.length > 0) {
                    stepSlider.min = 0;
                    stepSlider.max = state.stepsList.length - 1;
                    stepSlider.value = stepIndex;
                }

                // Update nav button states
                document.getElementById('btnFirst').disabled = stepIndex <= 0;
                document.getElementById('btnPrev').disabled = stepIndex <= 0;
                document.getElementById('btnNext').disabled = stepIndex >= totalSteps - 1;
                document.getElementById('btnLast').disabled = stepIndex >= totalSteps - 1;
            }
        }

        // Navigate to a specific step by direction
        function navigateToStep(direction) {
            const steps = state.runData?.steps || [];
            if (steps.length === 0) return;

            const currentIndex = state.stepsList.indexOf(state.selectedStep);
            let newIndex = currentIndex;

            switch(direction) {
                case 'first':
                    newIndex = 0;
                    break;
                case 'prev':
                    newIndex = Math.max(0, currentIndex - 1);
                    break;
                case 'next':
                    newIndex = Math.min(state.stepsList.length - 1, currentIndex + 1);
                    break;
                case 'last':
                    newIndex = state.stepsList.length - 1;
                    break;
            }

            navigateToStepIndex(newIndex);
        }

        // Navigate to a specific step by index
        function navigateToStepIndex(index) {
            if (index < 0 || index >= state.stepsList.length) return;

            state.selectedStep = state.stepsList[index];
            state.lastViewedStep = state.selectedStep; // Save for smart resume
            state.isLiveMode = false;
            updateHistoryUI();
            render();
        }

        // Update steps list when new data arrives
        function updateStepsList() {
            const steps = state.runData?.steps || [];
            state.stepsList = steps.map(s => s.step).sort((a, b) => a - b);

            // Update slider range
            const slider = document.getElementById('stepSlider');
            if (state.stepsList.length > 0) {
                slider.min = 0;
                slider.max = state.stepsList.length - 1;
            }
        }

        // Detect when training has ended (no new data for 10 seconds)
        let trainingTimeout = null;
        function resetTrainingTimeout() {
            if (trainingTimeout) clearTimeout(trainingTimeout);
            trainingTimeout = setTimeout(() => {
                state.isTrainingActive = false;
                if (state.isLiveMode) {
                    updateHistoryUI();
                }
            }, CONFIG.trainingTimeoutMs);
        }

        // Live/Pause toggle
        document.getElementById('btnLivePause').addEventListener('click', toggleLiveMode);

        // Navigation buttons
        document.getElementById('btnFirst').addEventListener('click', () => navigateToStep('first'));
        document.getElementById('btnPrev').addEventListener('click', () => navigateToStep('prev'));
        document.getElementById('btnNext').addEventListener('click', () => navigateToStep('next'));
        document.getElementById('btnLast').addEventListener('click', () => navigateToStep('last'));

        // Slider
        document.getElementById('stepSlider').addEventListener('input', (e) => {
            const index = parseInt(e.target.value);
            if (index >= 0 && index < state.stepsList.length) {
                navigateToStepIndex(index);
            }
        });

        function addStep(stepData) {
            if (!state.runData) {
                state.runData = { steps: [] };
            }

            const idx = state.runData.steps.findIndex(s => s.step === stepData.step);
            if (idx >= 0) {
                state.runData.steps[idx] = stepData;
            } else {
                state.runData.steps.push(stepData);
                state.runData.steps.sort((a, b) => a.step - b.step);
            }

            // Update per-layer history for pulse viz
            stepData.layers.forEach(layer => {
                if (!state.history[layer.layer_id]) {
                    state.history[layer.layer_id] = [];
                }
                state.history[layer.layer_id].push({
                    step: stepData.step,
                    actStd: layer.intermediate_features.activation_std,
                    gradNorm: layer.gradient_flow.gradient_l2_norm
                });
                if (state.history[layer.layer_id].length > CONFIG.historyLen) {
                    state.history[layer.layer_id].shift();
                }
            });

            // Track training activity
            state.lastSeenStep = stepData.step;

            updateStepsList();

            render();
        }

        function render() {
            if (!state.runData?.steps.length) return;

            const steps = state.runData.steps;

            // Determine which step to display
            let displayStep;
            if (state.isLiveMode) {
                displayStep = steps[steps.length - 1];
            } else {
                const stepData = steps.find(s => s.step === state.selectedStep);
                displayStep = stepData || steps[steps.length - 1];
            }

            if (!displayStep) return;

            // Update summary
            document.getElementById('stepVal').textContent = displayStep.step;
            document.getElementById('layerVal').textContent = displayStep.layers.length;
            document.getElementById('timeVal').textContent = new Date(displayStep.timestamp * 1000).toLocaleTimeString();

            // Update mode display if in live mode (show latest step info)
            if (state.isLiveMode) {
                document.getElementById('stepDisplay').textContent = `step ${displayStep.step}`;
            }

            // Check alerts (only in live mode)
            if (state.isLiveMode) {
                checkAlerts(displayStep);
            } else {
                // Hide alerts when viewing history
                document.getElementById('alerts').classList.remove('visible');
            }

            // Render layers
            const container = document.getElementById('layers');
            container.innerHTML = displayStep.layers.map(layer => {
                const health = assessHealth(layer);
                return `
                    <div class="layer ${health.class}">
                        <div class="layer-header">
                            <div>
                                <div class="layer-name">${layer.layer_id}</div>
                                <div class="layer-type">${layer.layer_type}</div>
                            </div>
                        </div>
                        <canvas class="pulse-viz" id="pulse-${layer.layer_id.replace(/[^a-z0-9]/gi, '-')}"></canvas>
                        <div class="metrics">
                            <div class="metric">
                                <div class="metric-value ${health.act}">${layer.intermediate_features.activation_std.toFixed(4)}</div>
                                <div class="metric-label">act std</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value ${health.grad}">${layer.gradient_flow.gradient_l2_norm.toFixed(4)}</div>
                                <div class="metric-label">grad norm</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value ${health.ratio}">${layer.intermediate_features.cross_layer_std_ratio?.toFixed(3) ?? '—'}</div>
                                <div class="metric-label">ratio</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Draw pulse lines with historical context
            displayStep.layers.forEach(layer => {
                drawPulse(layer.layer_id, displayStep.step);
            });
        }

        function assessHealth(layer) {
            const gradNorm = layer.gradient_flow.gradient_l2_norm;
            const gradMax = layer.gradient_flow.gradient_max_abs;
            const ratio = layer.intermediate_features.cross_layer_std_ratio;

            let health = 'good';
            let act = 'good';
            let grad = 'good';
            let ratioClass = 'good';

            if (gradNorm < CONFIG.thresholds.gradNorm.low) {
                health = 'critical';
                grad = 'bad';
            }
            if (gradMax > CONFIG.thresholds.gradMax.high) {
                health = 'critical';
                grad = 'bad';
            }
            if (ratio !== null) {
                if (ratio < CONFIG.thresholds.actRatio.low) {
                    health = health === 'good' ? 'warning' : health;
                    ratioClass = 'bad';
                }
                if (ratio > CONFIG.thresholds.actRatio.high) {
                    health = health === 'good' ? 'warning' : health;
                    ratioClass = 'warn';
                }
            }

            const classMap = { good: '', warning: 'warning', critical: 'critical' };
            return { class: classMap[health], act, grad, ratio: ratioClass };
        }

        function drawPulse(layerId, currentStep) {
            const canvas = document.getElementById(`pulse-${layerId.replace(/[^a-z0-9]/gi, '-')}`);
            if (!canvas) return;

            // Get history leading up to current step
            const allHistory = state.history[layerId] || [];

            // Find the 50 steps leading up to and including currentStep
            let pulseHistory = [];
            if (allHistory.length > 0) {
                const currentStepIndex = allHistory.findIndex(h => h.step === currentStep);
                if (currentStepIndex >= 0) {
                    // Show 50 steps leading up to current step
                    const startIdx = Math.max(0, currentStepIndex - CONFIG.historyLen + 1);
                    pulseHistory = allHistory.slice(startIdx, currentStepIndex + 1);
                } else {
                    // Current step not in history yet, use available history
                    pulseHistory = allHistory.slice(-CONFIG.historyLen);
                }
            }

            if (pulseHistory.length < 2) return;

            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const w = rect.width;
            const h = rect.height;

            ctx.clearRect(0, 0, w, h);

            // Find min/max for scaling
            let maxVal = 0;
            pulseHistory.forEach(pt => {
                maxVal = Math.max(maxVal, pt.actStd, pt.gradNorm);
            });
            maxVal = Math.max(maxVal, 0.001);

            // Draw activation line
            ctx.strokeStyle = '#4a9';
            ctx.lineWidth = 1.5;
            ctx.beginPath();

            pulseHistory.forEach((pt, i) => {
                const x = (i / (pulseHistory.length - 1)) * w;
                const y = h - (pt.actStd / maxVal) * h * 0.8 - h * 0.1;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Draw gradient line
            ctx.strokeStyle = '#a371f7';
            ctx.lineWidth = 1;
            ctx.beginPath();

            pulseHistory.forEach((pt, i) => {
                const x = (i / (pulseHistory.length - 1)) * w;
                const y = h - (pt.gradNorm / maxVal) * h * 0.8 - h * 0.1;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
        }

        function checkAlerts(step) {
            const alerts = [];

            step.layers.forEach(layer => {
                const gradNorm = layer.gradient_flow.gradient_l2_norm;
                const gradMax = layer.gradient_flow.gradient_max_abs;
                const ratio = layer.intermediate_features.cross_layer_std_ratio;

                if (gradNorm < 0.001) {
                    alerts.push({ type: 'critical', msg: `vanishing: ${layer.layer_id}` });
                }
                if (gradMax > 10) {
                    alerts.push({ type: 'critical', msg: `exploding: ${layer.layer_id}` });
                }
                if (ratio !== null && ratio < 0.1) {
                    alerts.push({ type: 'warning', msg: `severe drop: ${layer.layer_id}` });
                }
            });

            const alertDiv = document.getElementById('alerts');
            if (alerts.length) {
                alertDiv.innerHTML = alerts.map(a => `
                    <div class="alert ${a.type}">
                        <span class="alert-icon">${a.type === 'critical' ? '⚠' : '◷'}</span>
                        <span>${a.msg}</span>
                    </div>
                `).join('');
                alertDiv.classList.add('visible');
            } else {
                alertDiv.classList.remove('visible');
            }
        }

        connect();

        window.addEventListener('resize', () => {
            if (state.runData) render();
        });
    </script>
</body>
</html>
